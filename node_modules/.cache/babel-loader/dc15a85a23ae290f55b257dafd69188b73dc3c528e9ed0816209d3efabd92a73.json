{"ast":null,"code":"/* \r\n   该文件是对axios的二次封装，封装的目的是：\r\n      1.让每次请求都加上固定mock前缀:http://www.0410.com\r\n      2.让每次请求都加上超时时间\r\n      3.让每次请求都加上请求头school值为atguigu\r\n      4.让每次请求都加上进度条效果\r\n      5.让每次请求都将真正的数据返回给使用者（response.data）\r\n      6.让每次请求都能自动处理异常\r\n*/\nimport axios from 'axios';\nimport NProgress from 'nprogress';\nimport '@/theme/color.css';\n\n// 创建一个axios实例对象 —— request\nconst request = axios.create({\n  baseURL: 'http://www.0410.com',\n  timeout: 10000\n});\n\n// 请求拦截器 —— 本质就是一函数\nrequest.interceptors.request.use(config => {\n  // 进度条走起\n  NProgress.start();\n  // 请求头上追加school字段，值为atguigu，现在我们追加的是school，看似很无聊，但以后要追加的是token\n  config.headers.school = 'atguigu';\n  // 返回本次请求的配置,config是本次请求所有的详细配置\n  return config;\n});\n\n// 响应拦截器 —— 本质就是一函数\nrequest.interceptors.response.use(\n// 响应成功的回调\nresponse => {\n  // 进度条停止\n  NProgress.done();\n  // 返回真正的数据\n  return response.data;\n},\n// 响应失败的回调\nerror => {\n  // 进度条停止\n  NProgress.done();\n  // 第一种返回方式：将错误继续传递下去，让使用者，进一步做处理\n  // return Promise.reject(error.message)\n\n  // 第二种返回方式：直接提示将错误，终止Promise链，使用者无需配置失败的回调\n  alert(error.message);\n  return new Promise(() => {});\n});\nexport default request;","map":{"version":3,"names":["axios","NProgress","request","create","baseURL","timeout","interceptors","use","config","start","headers","school","response","done","data","error","alert","message","Promise"],"sources":["/Users/fuweixiang/Desktop/前端/git/demo/src/utils/mockRequest.js"],"sourcesContent":["/* \r\n   该文件是对axios的二次封装，封装的目的是：\r\n      1.让每次请求都加上固定mock前缀:http://www.0410.com\r\n      2.让每次请求都加上超时时间\r\n      3.让每次请求都加上请求头school值为atguigu\r\n      4.让每次请求都加上进度条效果\r\n      5.让每次请求都将真正的数据返回给使用者（response.data）\r\n      6.让每次请求都能自动处理异常\r\n*/\r\nimport axios from 'axios'\r\nimport NProgress from 'nprogress'\r\nimport '@/theme/color.css'\r\n\r\n// 创建一个axios实例对象 —— request\r\nconst request = axios.create({\r\n  baseURL:'http://www.0410.com',\r\n  timeout:10000\r\n})\r\n\r\n// 请求拦截器 —— 本质就是一函数\r\nrequest.interceptors.request.use((config)=>{\r\n  // 进度条走起\r\n  NProgress.start()\r\n  // 请求头上追加school字段，值为atguigu，现在我们追加的是school，看似很无聊，但以后要追加的是token\r\n  config.headers.school = 'atguigu'\r\n  // 返回本次请求的配置,config是本次请求所有的详细配置\r\n  return config\r\n})\r\n\r\n// 响应拦截器 —— 本质就是一函数\r\nrequest.interceptors.response.use(\r\n  // 响应成功的回调\r\n  response => {\r\n    // 进度条停止\r\n    NProgress.done()\r\n    // 返回真正的数据\r\n    return response.data\r\n  },\r\n  // 响应失败的回调\r\n  error => {\r\n    // 进度条停止\r\n    NProgress.done()\r\n    // 第一种返回方式：将错误继续传递下去，让使用者，进一步做处理\r\n    // return Promise.reject(error.message)\r\n\r\n    // 第二种返回方式：直接提示将错误，终止Promise链，使用者无需配置失败的回调\r\n    alert(error.message)\r\n    return new Promise(()=>{})\r\n  }\r\n)\r\n\r\nexport default request"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,SAAS,MAAM,WAAW;AACjC,OAAO,mBAAmB;;AAE1B;AACA,MAAMC,OAAO,GAAGF,KAAK,CAACG,MAAM,CAAC;EAC3BC,OAAO,EAAC,qBAAqB;EAC7BC,OAAO,EAAC;AACV,CAAC,CAAC;;AAEF;AACAH,OAAO,CAACI,YAAY,CAACJ,OAAO,CAACK,GAAG,CAAEC,MAAM,IAAG;EACzC;EACAP,SAAS,CAACQ,KAAK,CAAC,CAAC;EACjB;EACAD,MAAM,CAACE,OAAO,CAACC,MAAM,GAAG,SAAS;EACjC;EACA,OAAOH,MAAM;AACf,CAAC,CAAC;;AAEF;AACAN,OAAO,CAACI,YAAY,CAACM,QAAQ,CAACL,GAAG;AAC/B;AACAK,QAAQ,IAAI;EACV;EACAX,SAAS,CAACY,IAAI,CAAC,CAAC;EAChB;EACA,OAAOD,QAAQ,CAACE,IAAI;AACtB,CAAC;AACD;AACAC,KAAK,IAAI;EACP;EACAd,SAAS,CAACY,IAAI,CAAC,CAAC;EAChB;EACA;;EAEA;EACAG,KAAK,CAACD,KAAK,CAACE,OAAO,CAAC;EACpB,OAAO,IAAIC,OAAO,CAAC,MAAI,CAAC,CAAC,CAAC;AAC5B,CACF,CAAC;AAED,eAAehB,OAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}